#
# This program responds via ALexa TTS to trigger events generated by the Alexa App routines function.
# It responds with generated spoken description of state of the triggered entity. 
# 
# It requires a template light switch is created in HA 
#
# - platform: template
#    lights:
#      alexa_virtual:
#        friendly_name: "Alexa Dummy Light"
#        turn_on:
#
#        turn_off:
#
#        set_level:
#
# This dummy light switch brightness level is used to generate 100 unique triggers.
# Each trigger is matched to a list of entities to create the following type of Alexa conversations
#
# "Alexa is the patio door open"            (created in the Alexa app Routine)
# "Please wait while I check"               (created in the Alexa app Routine)
#  Set dummy Light bulb brightness to 1%    (created in the Alexa app Routine)
# "The patio door is closed"                (created by this app)
#
# Program requires the following parameters
#
# AlexaReport:
# module: AlexaReport
# class: Alexareport
# trigger: "< name of dummy light >"
# ent:
#   - < name of sensor 1 >
#   - < name of sensor 2 >
#   - < etc >
#
# sonsor position matches dummy bulb brightness level  
# 
#
# Version 1.1
#
#
#
#
#


import appdaemon.plugins.hass.hassapi as hass
class Alexareport(hass.Hass):
    def initialize(self):
# get vars
        self.trigger=self.args["trigger"]
# check if dummy bulb  triggered
        self.listen_state(self.alexareport,self.trigger,new="on")
    def alexareport (self, entity, attribute, old, new, kwargs):
        self.log(("{} triggered").format(self.trigger))
        import subprocess

# get last lastalexa from sensor 
        self.call_service("homeassistant/update_entity",entity_id = "sensor.last_alexa")
        alexa = self.get_state("sensor.last_alexa")
        self.log("Last Alexa is {}".format(alexa))
# dim value of dummy light
        value = self.get_state(self.trigger, attribute = "brightness")
# Convert brightness 0 to 255 as persentage  then -1 as python list start 0 not 1
        psent = int(round(value/255*100)) -1
        self.log("message no {}".format(psent))
#get ent list
        ent = self.args["ent"]
# Test if dim value matches listnumber in  array -1 as array start at 0
        if psent > (len(ent) -1) :
# Dim value does not match entry in list error and turn off dummy light
            self.log("Message {} value out of range ignored".format(psent+1))
            self.turn_off(self.trigger)
            return()
# get time and date in words
        num2words = {1: 'first', 2: 'second', 3: 'third', 4: 'fourth', 5: 'fifth', \
                    6: 'Sixth', 7: 'seventh', 8: 'eighth', 9: 'ninth', 10: 'tenth', \
                    11: 'eleventh', 12: 'twelfth', 13: 'thirteenth', 14: 'fourteenth', \
                    15: 'fifteenth', 16: 'seventeenth', 17: 'seventeenth', 18: 'eighteenth', \
                    19: 'nineteenth',20:"twentieth",21:"twenty first",22:"twenty second", \
                    23:"twenty third",24:"twenty fourth",25:"twenty fifth",26:"twenty sixth", \
                    27:"twenty seventh",28:"twenty eighth",29:"twenty ninth",30:"thirtieth",31:"thirty-first"}
        now = self.datetime()
        year = now.strftime("%Y")
        day  = now.strftime("%A")
        dayn = (now.strftime("%d"))
        dayw = num2words[int(dayn)]
        month = now.strftime("%B")
        mn = now.strftime("%M")
        hour = now.strftime("%I")
        am_pm = now.strftime("%p")
        time = hour + " " + mn + " " + am_pm
        self.log("{} {} {} {} {} {}".format(now,day,dayw,month,year,time))
        raw = ent[psent]
        self.log("Raw data = {}".format(raw))
        et = []
        for i in range(9) :
            et.append("")
        p1 = raw.find("(") 
        while p1 > 0 :
            p2 = raw.find(")") + 1
            parse = raw[p1:p2]
            cmd = parse[1]
            if cmd == "e" :
                pt = int(parse[2]) 
                et[pt] = parse[4:(len(parse)-1)]
                if parse[3] == "=" :
                    fname  = self.get_state(et[pt], attribute="friendly_name")
                else :
                    fname = ""
                raw = raw.replace(parse,fname)
            if cmd == "s" :
                pt = int(parse[2]) 
                st = parse[4:(len(parse)-1)]
                rp = st.find("|")
                if rp == -1 :
                    rp = len(st)
                state = str(self.get_state(et[pt], attribute=(st[:rp])))
                rep = st[rp+1:].split("|")
                for i in range(len(rep)-1) :
                    state = state.replace(rep[i],rep[i+1])
                state = state.replace("."," point ")
                raw = raw.replace(parse,state)
                self.log("Current parse is {}".format(raw))
            if cmd == "D" :
                raw = raw.replace(parse,day)
            if cmd == "d" :
                raw = raw.replace(parse,dayw)    
            if cmd == "m" :
                raw = raw.replace(parse,month)
            if cmd == "y" :
                raw = raw.replace(parse,year)
            if cmd == "t" :
                raw = raw.replace(parse,time)
            p1 = raw.find("(")
        raw = raw.replace("  "," ")
        raw = raw.replace("  "," ")
        self.log("Message {} {}".format(psent,raw))
        params = "- d " + "'" + alexa + "'" + " -e speak:" + raw
#send message to alexa and turn off dummy bulb
# self.call_service("shell_command/alexa", params = talkmess)
        self.turn_off(self.trigger)
            
        
        
